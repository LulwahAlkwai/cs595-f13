   #[1]RSS 2.0 [2]RSS .92 [3]Atom 1.0

[4]To solve hard problems, you need to use bricolage

   People who think that they can design efficient solutions in the
   abstract, effectively believe in Oracles. That is, they somehow believe
   that from their desk, and using only their mind, they can anticipate
   all the implementation issues that will come up after hours of
   programming. They somehow believe that before they even start building
   the software, they can know everything there is to know about a
   practical problem.

   In a [5]talk about a neat software component he designed, Bruce Haddon
   observed that there is no way that the final structure and algorithmic
   behavior of this component could have been predicted, designed, or
   otherwise anticipated.

   Haddon observed that computer science serves as a source of core ideas:
   it provides the data structures and algorithms that are the building
   blocks. Meanwhile, he views software engineering as a useful set of
   methods to help design reliable software without losing your mind. Yet
   he points out that neither captures the whole experience.

   That's because much of the work is what Haddon calls hacking, but what
   others would call bricolage. Simply put, there is much trial and error:
   we put ideas to together and see where it goes.

   It is common to be dismissive of bricolage (or hacking). However, I
   think it is a grave mistake to discourage it.

   It is common that my students will ask me "how do I do X?" and my
   answer is "try something, anything." Though I don't put it in words, I
   am encouraging them to use bricolage. I may need to urge them 2 or 3
   times before they try it. And you know what happens? Often the student
   actually solves the problem!

   I believe that a common process is as follows:
     * You are given a problem. You lack the necessary information to
       solve it. For example, maybe you are in Europe and you want to go
       to India but you have no map.
     * You could try to build a simplified model of the problem and solve
       that. For example, you might decide that the world is round and
       that you simply have to sail West. There is no harm done unless
       hubris takes over and you conclude hastily that the problem is
       effectively solved. Something you did not know that you did not
       know might get in the way (e.g., there is an extra continent called
       America in your way).
     * You could try something, anything. Chances are that it will fail.
       If it does, chances are that you will learn something. Something
       that might not have been obvious. For example, you may decide to go
       South along the coast of Africa. In the process, you may discover
       cities ripe for plunder.

   Most problems become reasonably easy once you have all the relevant
   information. The really difficult problems are such that you lack
   critical information. And, hence, almost all hard problems require
   bricolage.
   [6]Tweet
   [7]Comments (1)

1 Comment

    1. A very timely column. I work with a software company that's
       releasing a version of our product in about a month's time. At this
       point we seem to have mostly UI bugs that I have no clue about. I
       decided to try and help out - it is amazing how much information
       you can gather by just diff'ing files or comparing them across
       branches. Thank you.
       Comment by Anonymous -- 18/9/2013 @ [8]17:15

   Sorry, the comment form is closed at this time.
   « « [9]Previous: Are 8-bit or 16-bit counters faster than 32-bit
   counters?
   [10]Next: What do computer scientists know about performance? » »

   [11]« Blog's main page
   Daniel Lemire's picture
     * [12]Daniel Lemire's blog
       Canadian flag Montreal, Canada
     * Google Plus logo [13]Follow on Google Plus
       22,500 followers
     * twitter logo [14]Follow @lemire
       4,000 followers
     * Facebook logo [15]Follow on Facebook
     * Google Scholar logo [16]Follow on Google Scholar
     * Subscribe to this blog
       - [17]in a reader,
       - [18]on your kindle,
       - or ____________________ Subscribe by email
     * Search through 1420 posts and 5847 comments:
       ____________________
       Search
     *
          + [19]About me
          + [20]Book recommendations
          + [21]My readers
          + [22]Terms of use
          + [23]Write good papers
     * Recent Comments:
          + Thierry Lhôte on [24]The written word took over the world
          + Thierry Lhôte on [25]The written word took over the world
          + Ben on [26]The written word took over the world
          + Anonymous on [27]The written word took over the world
          + kilian on [28]The written word took over the world
     * Some popular posts
          + [29]Why I still program
          + [30]Emotions killing your intellectual productivity
          + [31]Turn your weaknesses into strengths
          + [32]It is not where you work, but who you work with
     * [33]Home page
       [34]Google Scholar profile
       [35]arXiv
       [36]DBLP

   Powered by [37]WordPress

   © 2004-2013, [38]Daniel Lemire (lemire at gmail dot com). This work is
   licensed under a [39]Creative Commons License.

References

   Visible links
   1. http://lemire.me/blog/feed/
   2. http://lemire.me/blog/feed/rss/
   3. http://lemire.me/blog/archives/2013/09/16/bricolage/atom
   4. http://lemire.me/blog/archives/2013/09/16/bricolage/
   5. http://www.boulderstartups.org/ai1ec_event/cu-cs-colloquium-is-it-computer-science-software-engineering-or-hacking/?instance_id=
   6. https://twitter.com/share
   7. http://lemire.me/blog/archives/2013/09/16/bricolage/#comments
   8. http://lemire.me/blog/archives/2013/09/16/bricolage/?utm_source=feedburner#comment-93816
   9. http://lemire.me/blog/archives/2013/09/13/are-8-bit-or-16-bit-counters-faster-than-32-bit-counters/
  10. http://lemire.me/blog/archives/2013/09/17/computer-scientists-and-performance/
  11. http://lemire.me/blog/
  12. http://lemire.me/
  13. https://plus.google.com/105888615414982242080/about
  14. http://www.twitter.com/lemire/
  15. http://www.facebook.com/daniel.lemire
  16. http://scholar.google.com/citations?sortby=pubdate&hl=en&user=q1ja-G8AAAAJ&view_op=list_works
  17. http://lemire.me/blog/feed/
  18. http://www.amazon.com/Daniel-Lemires-blog/dp/B002DPV7QQ?SubscriptionId=AKIAILSHYYTFIVPWUY6Q
  19. http://lemire.me/blog/about-me/
  20. http://lemire.me/blog/book-recommendations/
  21. http://lemire.me/blog/my-readers/
  22. http://lemire.me/blog/terms-of-use/
  23. http://lemire.me/blog/rules-to-write-a-good-research-paper/
  24. http://lemire.me/blog/archives/2013/10/01/the-written-word/#comment-95660
  25. http://lemire.me/blog/archives/2013/10/01/the-written-word/#comment-95652
  26. http://lemire.me/blog/archives/2013/10/01/the-written-word/#comment-95627
  27. http://lemire.me/blog/archives/2013/10/01/the-written-word/#comment-95596
  28. http://lemire.me/blog/archives/2013/10/01/the-written-word/#comment-95584
  29. http://lemire.me/blog/archives/2011/06/06/why-i-still-program/
  30. http://lemire.me/blog/archives/2009/01/20/emotions-killing-your-intellectual-productivity/
  31. http://lemire.me/blog/archives/2009/01/19/turn-your-weaknesses-into-strengths/
  32. http://lemire.me/blog/archives/2011/10/25/it-is-not-where-you-work-but-who-you-work-with/
  33. http://lemire.me/en/
  34. http://scholar.google.com/citations?sortby=pubdate&hl=en&user=q1ja-G8AAAAJ&view_op=list_works
  35. http://arxiv.org/a/lemire_d_1
  36. http://www.informatik.uni-trier.de/~ley/db/indices/n-tree/l/Lemire:Daniel.html
  37. http://wordpress.org/
  38. http://lemire.me/en/
  39. http://creativecommons.org/licenses/by-sa/2.0/

   Hidden links:
  40. http://lemire.me/blog/feed/

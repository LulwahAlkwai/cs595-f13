<!DOCTYPE html> <!--[if lt IE 7]><html class="no-js ie6" lang="en"><![endif]--> <!--[if IE 7]><html class="no-js ie7" lang="en"><![endif]--> <!--[if IE 8]><html class="no-js ie8" lang="en"><![endif]--> <!--[if gt IE 8]><!--> <html class="no-js" lang="en"> <!--<![endif]--> <head> <meta charset="utf-8"> <meta content="IE=edge" http-equiv="X-UA-Compatible"> <meta content="nanoc 3.7" name="generator"> <meta content="notranslate" name="google"> <title>PackedArray: Packing Unsigned Integers Tightly | PEMPEK.NET</title> <meta content="Grégory Pakosz (c) 2013" name="copyright"> <meta content="cache, oblivious, dense, cpp, cxx, succint, packed, array, bit, packing, bit-packing, programming, data-structures, optimization, c, c++" name="keywords"> <link href="../../../../../humans.txt" rel="author"> <link href="../../../../../feed/" rel="alternate" title="PEMPEK.NET" type="application/atom+xml"> <link href="../../../../../css/main.css?4073011742" rel="stylesheet"> <script src="../../../../../js/all.js?996676760"></script> </head> <body> <div class="all"> <div class="border-top"> <a id="top"></a> <a class="to-content" href="#content">skip to content</a> <header class="header"> <nav class="primary-nav" role="navigation"> <ul> <li><a href="../../../../../">Home</a></li> <li><a class="active" href="../../../../">Articles</a></li> <li><a href="../../../../../blog/">Blog</a></li> <li><a href="../../../../../about/">About</a></li> </ul> </nav> </header> <div class="content" id="content"> <div class="wrapper"> <div class="left-wrapper"> <div class="left"> <nav class="breadcrumbs" role="navigation"><a href="../../../../">Articles Archive</a><span class="breadcrumbs-separator"> :: </span><a href="../../../">2013</a><span class="breadcrumbs-separator"> :: </span><a href="../../">August</a><span class="breadcrumbs-separator"> :: </span><a href="../">03</a><span class="breadcrumbs-separator"> :: </span></nav> <article class="article"> <h1 class="title">PackedArray: Packing Unsigned Integers Tightly</h1> <p>For a long time, I’ve been wanting to release my implementation of random access container capable of randomly accessing unsigned integers packed at the bit-level.</p> <p><strong>Meet PackedArray.</strong></p> <p>When you want to hold an unordered sequence of unsigned integers into memory, the C programming language lets you choose among 4 data types:</p> <ul> <li><code>uint8_t</code></li> <li><code>uint16_t</code></li> <li><code>uint32_t</code></li> <li><code>uint64_t</code></li> </ul><p>If your numbers are within the [0, 100000] range, only 17 bits per integer are needed since 2<sup>17</sup> = 131072. However, you can’t use an array of <code>uint16_t</code> because 16 bits are not enough to store numbers between 65536 and 100000. When you use the next available type, <code>uint32_t</code>, you’re wasting 15 bits per integer which represents a 47% overhead in terms of storage requirements.</p> <p><code>PackedArray</code> comes to the rescue e.g. when you’re in a desperate need for a <code>uint9_t</code> or <code>uint17_t</code> array. <code>PackedArray</code> is a bit packer. Bit packing consists in saving memory by packing integers/items together at the bit-level:</p> <table class="monospace"> <tr> <td colspan="32">b0</td> <td colspan="32">b1</td> <td colspan="32">b2</td> <td style="border-style: dashed; border-right: none;">&#8230;</td> </tr> <tr> <td colspan="9">i0</td> <td colspan="9">i1</td> <td colspan="9">i2</td> <td colspan="9">i3</td> <td colspan="9">i4</td> <td colspan="9">i5</td> <td colspan="9">i6</td> <td colspan="9">i7</td> <td colspan="9">i8</td> <td colspan="9">i9</td> <td style="border-style: dashed; border-right: none;">&#8230;</td> </tr> </table><p>A <code>PackedArray</code> is backed by an <code>uint32_t</code> buffer. Several items end up being stored inside the same buffer cell, e.g. i0, i1, and i2. Some items span two buffer cells, e.g. i3, and i7. <code>PackedArray</code> is responsible for encoding/decoding items into/from the storage buffer.</p> <h2 id="discussion">Discussion</h2> <p><code>PackedArray</code>’s main purpose is not data serialization or message encoding: for that, one would typically investigate fast compression algorithms like <a href="https://code.google.com/p/lz4/">LZ4</a> or <a href="https://code.google.com/p/snappy/">Snappy</a>.</p> <p><strong>Random access and dense data are the key features.</strong></p> <p><code>PackedArray</code> is designed as a drop-in replacement for an unsigned integer array yet imposes the following requirements:</p> <ul> <li>you must know in advance how many bits are needed to hold a single item</li> <li>you must know in advance how many items you want to store</li> <li>when packing, behavior is undefined if items have more than the specified maximum bits per item</li> </ul><p>Instead of writing:</p> <pre><code>uint32_t* a = (uint32_t*)malloc(sizeof(uint32_t) * count);&#x000A;...&#x000A;value = a[i];&#x000A;...&#x000A;a[j] = value;&#x000A;</code></pre> <p>You write:</p> <pre><code>PackedArray* a = PackedArray_create(bitsPerItem, count);&#x000A;...&#x000A;value = PackedArray_get(a, i);&#x000A;...&#x000A;PackedArray_set(a, j, value);&#x000A;</code></pre> <p>There are also <code>PackedArray_pack</code> and <code>PackedArray_unpack</code> that operate on several items in a row. Those two could really have been named <code>PackedArray_write</code> and <code>PackedArray_read</code> but I decided “pack” / “unpack” conveys better something is happening under the hood.</p> <pre><code>// bulk packing / unpacking&#x000A;PackedArray_pack(a, j, in, count);&#x000A;PackedArray_unpack(a, j, out, count);&#x000A;&#x000A;// the following are semantically equivalent&#x000A;PackedArray_set(a, j, value);&#x000A;PackedArray_pack(a, j, &amp;value, 1);&#x000A;&#x000A;value = PackedArray_get(a, i);&#x000A;PackedArray_unpack(a, i, &amp;value, 1);&#x000A;</code></pre> <p>Current implementations of <code>PackedArray_pack</code> and <code>PackedArray_unpack</code> are unrolled and generated with the help of the C preprocessor. Unrolling brings the following micro-benchmark speed gains (compiled with <code>-O2</code>):</p> <ul> <li>76%, Macbook Pro Mid 2010 (2,67GHz Core i7 M 620)</li> <li>50%, Samsung Galaxy Note (1.4 GHz ARM Cortex-A9)</li> <li>79%, iPhone 5 (1.3 GHz ARM Apple A6)</li> </ul><p>References implementations can be found inside the <code>PackedArray.c</code> file yet are compiled out unless compiling in self-test mode. Those reference implementations can conceptually be viewed as loops around <code>PackedArray_set</code> and <code>PackedArray_get</code>.</p> <p>To better understand the unrolling happening in <code>PackedArray_pack</code> and <code>PackedArray_unpack</code>, it is possible to generate a preprocessed version of <code>PackedArray.c</code>, see instructions in <code>README.md</code>.</p> <p><code>PackedArray</code> is released under the WTFPL v2 and is available on my <a href="https://github.com/gpakosz/PackedArray">GitHub account</a>.</p> <h2 id="going-simd">Going SIMD</h2> <p>After having unrolled <code>PackedArray_pack</code> and <code>PackedArray_unpack</code> I started wondering about speeding it up further with SIMD instructions. Looking for prior art, it seems that I found the most comprehensive study on the subject: <a href="http://arxiv.org/abs/1209.2137">Decoding billions of integers per second through vectorization</a> by <a href="https://twitter.com/lemire">Daniel Lemire</a> and <a href="https://twitter.com/srchvrs">Leonid Boystov</a>.</p> <p>I initially tried to implement an SIMD version compatible with the non SIMD one. This would involve independent shifts on the vector components (available with NEON, doable by multiplying with SSE2) and also horizontal adds.</p> <p>However, as described in the paper, it is possible to replace scalar shifts and logical operations (or, and, not) with their SIMD equivalent instructions. Packing with SIMD instructions processes integers 4 by 4 but imposes an interleaved layout in the storage buffer.</p> <p>Interleaved layout, 13 bits per item:</p> <table class="monospace"> <tr> <td colspan="32">b0</td> <td colspan="32">b1</td> <td colspan="32">b2</td> <td colspan="32">b3</td> <td style="border-style: dashed; border-right: none;">&#8230;</td> </tr> <tr> <td colspan="13">i0</td> <td colspan="13">i4</td> <td colspan="6">i8a</td> <td colspan="13">i1</td> <td colspan="13">i5</td> <td colspan="6">i9a</td> <td colspan="13">i2</td> <td colspan="13">i6</td> <td colspan="6">i10a</td> <td colspan="13">i3</td> <td colspan="13">i7</td> <td colspan="6">i11a</td> <td style="border-style: dashed;">i8b</td> <td style="border-style: dashed; border-right: none;">&#8230;</td> </tr> </table><p>As a consequence, the data layout of <code>PackedArraySIMD</code> isn’t compatible with its non-SIMD counterpart. In other words, you cannot use <code>PackedArray</code> to unpack data packed with <code>PackedArraySIMD</code> or the other way around.</p> <p><code>PackedArraySIMD.c</code> implements packing at the bit-level using SSE2 or NEON instructions.</p> <p><code>PackedArraySIMD</code> compiled as self-bench exhibits the following speed improvements over <code>PackedArray</code>:</p> <ul> <li>60%, Macbook Pro Mid 2010 (2,67GHz Core i7 M 620)</li> <li>16%, Samsung Galaxy Note (1.4 GHz ARM Cortex-A9)</li> <li>22%, iPhone 5 (1.3 GHz ARM Apple A6)</li> </ul><p>Since this is a micro-benchmark, you will experience different behaviors depending on your platform, the amount of data you process, and the access pattern.</p> <p>It is also worth noting the implementations of <code>PackedArraySIMD_pack</code> and <code>PackedArraySIMD_unpack</code> require more plumbing than their non-SIMD counterparts. Additional computations are needed to find out and adjust a data window that can be processed 4 by 4 with SIMD instructions.</p> <h2 id="whats-next">What’s next?</h2> <p><code>PackedArray</code> and <code>PackedArraySIMD</code> serve as building blocks for more elaborate data structures. If you decide to build on top of it, I would appreciate you drop me a note :).</p> <p>In any case, feedback on the implementation and/or suggestions are greatly appreciated. Particularly, I’m no SIMD expert so if you find ways to further improve the implementation, please <a href="https://github.com/gpakosz/PackedArray/fork">fork the GitHub project and send me a pull request</a>.</p> <aside> <nav class="tags" role="navigation"><a href="../../../../../tags/programming/" rel="tag" class="tag">programming</a> <a href="../../../../../tags/data-structures/" rel="tag" class="tag">data-structures</a> <a href="../../../../../tags/optimization/" rel="tag" class="tag">optimization</a> <a href="../../../../../tags/c/" rel="tag" class="tag">c</a> <a href="../../../../../tags/cpp/" rel="tag" class="tag">c++</a></nav> </aside> </article> </div> </div> <div class="right-wrapper"> <div class="right"> <aside> <!--[if lt IE 9 ]><p class="browser-upgrade"> You are using an <strong>outdated</strong> browser. Please <a href="http://browsehappy.com/">upgrade</a> to <strong>improve your <del>experience</del> life</strong>. </p><![endif]--> </aside> </div> </div> </div> </div> <footer class="footer"> <div class="links"> <a href="/archive/"> <span aria-hidden="true" class="icon icon-archive"></span> <span class="screen-reader">archive</span> </a> <a href="/feed/"> <span aria-hidden="true" class="icon icon-feed"></span> <span class="screen-reader">feed</span> </a> <a href="https://twitter.com/gpakosz"> <span aria-hidden="true" class="icon icon-twitter"></span> <span class="screen-reader">twitter</span> </a> <a href="https://github.com/gpakosz"> <span aria-hidden="true" class="icon icon-github"></span> <span class="screen-reader">github</span> </a> </div> <div class="license"> <a class="cc" href="http://creativecommons.org/licenses/by-nc-sa/3.0" rel="license"> <span aria-hidden="true" class="icon icon-cc"></span> <span aria-hidden="true" class="icon icon-cc-by"></span> <span aria-hidden="true" class="icon icon-cc-nc"></span> <span aria-hidden="true" class="icon icon-cc-sa"></span> <span class="screen-reader">The content of this web site is licensed under a Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License</span> Grégory Pakosz © 2013&#8212; </a> </div> <a class="to-top" href="#top"> <span aria-hidden="true" class="icon icon-arrow-up"></span> <span class="screen-reader">scroll to top</span> </a> <div class="mentions-wrapper"> <div class="mentions"> Made with <a href="http://nanoc.ws" rel="nofollow">nanoc</a> by Denis Defreyne <br> <a href="http://www.entypo.com/" rel="nofollow">Entypo pictograms</a> by Daniel Bruce &#8212; <a href="http://subtlepatterns.com/light-paper-fibers/" rel="nofollow">Subtle Pattern</a> by Jorge Fuentes &#8212; <a href="http://typo3.org/the-brand/style-guide/the-typo3-font/" rel="nofollow">Share font</a> by Ralph du Carrois &#8212; Modified <a href="http://www.fontspace.com/jackster-productions/diskun" rel="nofollow">Diskun font</a> by Garon Rossignol </div> </div> </footer> </div> </div> </body> </html>